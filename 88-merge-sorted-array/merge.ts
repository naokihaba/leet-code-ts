/**
 * 88. ソート済み配列のマージ
 *
 * 2つの整数配列 nums1 と nums2 が与えられます。どちらも非減少順（昇順）で
 * ソートされています。また、2つの整数 m と n が与えられ、それぞれ
 * nums1 と nums2 の要素数を表します。
 *
 * nums1 と nums2 を1つのソートされた配列にマージしてください。
 *
 * 最終的なソート済み配列は関数から返すのではなく、nums1 の中に直接
 * 格納してください。これを可能にするため、nums1 の長さは m + n になっており、
 * 最初の m 個の要素がマージ対象、残りの n 個の要素は 0 で埋められています。
 *
 * 例1:
 * 入力: nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3
 * 出力: [1,2,2,3,5,6]
 * 説明: マージする配列は [1,2,3] と [2,5,6] です。
 *       結果は [1,2,2,3,5,6] となります。
 *
 * 例2:
 * 入力: nums1 = [1], m = 1, nums2 = [], n = 0
 * 出力: [1]
 * 説明: マージする配列は [1] と [] です。結果は [1] となります。
 *
 * 例3:
 * 入力: nums1 = [0], m = 0, nums2 = [1], n = 1
 * 出力: [1]
 * 説明: マージする配列は [] と [1] です。結果は [1] となります。
 *       m = 0 なので nums1 には要素がありません。
 *       0 はマージ結果を格納するためのスペースです。
 *
 * 制約:
 * - nums1.length == m + n
 * - nums2.length == n
 * - 0 <= m, n <= 200
 * - 1 <= m + n <= 200
 * - -10^9 <= nums1[i], nums2[j] <= 10^9
 *
 * フォローアップ: O(m + n) の時間計算量のアルゴリズムを考えられますか？
 */
export function merge(nums1: number[], m: number, nums2: number[], n: number): void {
  /**
   * === 初期状態 ===
   * nums1 = [1,2,3,0,0,0]
   * nums2 = [2,5,6]
   * i=2, j=2, k=5
   */
  let i = m - 1
  let j = n - 1
  let k = m + n - 1

  while (i >= 0 && j >= 0) {
    /**
     * 比較: nums1[2]=3 vs nums2[2]=6
     * nums2[2]=6 の方が大きい（または同じ）
     * nums1[5] に 6 を配置
     * nums1 = [1,2,3,0,0,6]
     * 次: i=2, j=1, k=4
     * 
     * 比較: nums1[2]=3 vs nums2[1]=5
     * → nums2[1]=5 の方が大きい（または同じ）
     * → nums1[4] に 5 を配置
     * nums1 = [1,2,3,0,5,6]
     * 次: i=2, j=0, k=3
     * 
     * 比較: nums1[2]=3 vs nums2[0]=2
     * → nums1[2]=3 の方が大きい
     * → nums1[3] に 3 を配置
     * nums1 = [1,2,3,3,5,6]
     * 次: i=1, j=0, k=2
     * 
     * 比較: nums1[1]=2 vs nums2[0]=2
     * → nums2[0]=2 の方が大きい（または同じ）
     * → nums1[2] に 2 を配置
     * nums1 = [1,2,2,3,5,6]
     * i=1, j=-1, k=1
     */
    if (nums1[i] > nums2[j]) {
      nums1[k] = nums1[i]
      i--
      k--
    } else {
      nums1[k] = nums2[j]
      j--
      k--
    }
  }

  while (j >= 0) {
    nums1[k] = nums2[j]
    j--
    k--
  }
}

// テスト実行
// merge([1, 2, 3, 0, 0, 0], 3, [2, 5, 6], 3)
// merge([1], 1, [], 0)

/**
 * === 初期状態 ===
 * nums1 = [0]
 * nums2 = [1]
 * m = 0 n = 1
 * 
 * let i = m - 1 = -1
 * let j = n - 1 = 0
 * let k = m + n - 1 = 0 + 1 - 1 = 0
 */
// merge([0], 0, [1], 1)

